import Matter, { Events, Engine, World, Bodies } from "matter-js";
import io, { Socket } from "socket.io-client"

interface MatterModules {
    Engine: typeof Matter.Engine;
    Render: typeof Matter.Render;
    Runner: typeof Matter.Runner;
    Bodies: typeof Matter.Bodies;
    Body: typeof Matter.Body;
    Composite: typeof Matter.Composite;
    Mouse: typeof Matter.Mouse;
    MouseConstraint: typeof Matter.MouseConstraint;
}

interface MatterObjects {
    engine: any
    render: any
    runner: any
    mouse: any
    mouseConstraint: any
}

interface MatterBodies {
    ball: Matter.Body
    leftPaddle: Matter.Body
    rightPaddle: Matter.Body
    myPaddle: Matter.Body
    othersPaddle: Matter.Body
    ground: Matter.Body
    roof: Matter.Body
    wall: Matter.Body
    wallLeft: Matter.Body
    circleA: Matter.Body
    circleB: Matter.Body
    circleC: Matter.Body
    centerLine: Matter.Body

}
interface measurements {
    divHeight: number,
    divWidth: number,
    ball: { x: number, y: number, radius: number },
    wallBottom: { x: number, y: number, width: number, height: number },
    wallTop: { x: number, y: number, width: number, height: number },
    wallLeft: { x: number, y: number, width: number, height: number },
    wallRight: { x: number, y: number, width: number, height: number },
    leftPaddle: { x: number, y: number, width: number, height: number },
    rightPaddle: { x: number, y: number, width: number, height: number },

}

interface Score {
    left: number;
    right: number;
}

interface SetScoreFn {
    (score: Score): void;
}
interface SetCountDownfn {
    (countDown: number): void;
}
interface gameTexture {
    leftP: string,
    rightP: string,
    wall: string,
    ball: string,
    background: string,
}
interface solidBodies {

}
// function saveMeasurements(div: HTMLElement, obj: measurements){
//     obj = {
//         divHeight: div.clientHeight,
//         divWidth: div.clientWidth,
//         wallBottom: {x: div.clientWidth / 2, y : div.clientHeight, width: div.clientWidth, height: 20},
//         wallTop: {x: div.clientWidth / 2, y : 0, width: div.clientWidth, height: 20},
//         wallLeft: {x: 0, y : div.clientHeight / 2, width: 20, height: div.clientHeight},
//         wallRight: {x: div.clientWidth , y : div.clientHeight / 2, width: 20, height: div.clientHeight},
//     }
// }
export class matterJsModules {
    socket: Socket
    modules: MatterModules;
    objects: MatterObjects = { engine: null, render: null, runner: null, mouse: null, mouseConstraint: null };
    bodies: MatterBodies
    paddleSide: string = ""
    matterContainer = document.querySelector("#matter-Container") as HTMLElement
    obj: measurements
    colors: gameTexture
    // solids : solidBodies
    constructor(roomId: string) {
        const windowHeight = window.innerHeight;
        console.log('Window height:', windowHeight);
        this.socket = io('http://localhost:3008');
        this.obj = this.saveMeasurements({ width: 375, height: 375 * (16 / 9) })
        this.socket.emit('joinRoom', { roomId: roomId});
        this.colors = {
            leftP: "#6DA9E4",
            rightP: "#F6BA6F",
            wall: "#FFEBEB",
            ball: "red",
            background: "#ADE4DB",
        }
        this.modules = {
            Engine: Matter.Engine,
            Render: Matter.Render,
            Runner: Matter.Runner,
            Bodies: Matter.Bodies,
            Body: Matter.Body,
            Composite: Matter.Composite,
            Mouse: Matter.Mouse,
            MouseConstraint: Matter.MouseConstraint,
        }
        this.bodies = {
            ball: this.modules.Bodies.circle(500, 500, 20, { isStatic: true, label: "ball" }),
            circleA: this.modules.Bodies.circle(this.obj.divWidth / 2, this.obj.divHeight / 2, 80, { isStatic: true, collisionFilter: { group: -1, }, render: { fillStyle: this.colors.wall }, label: "circleA" }),
            circleB: this.modules.Bodies.circle(this.obj.divWidth / 2, this.obj.divHeight / 2, 70, { isStatic: true, collisionFilter: { group: -1, }, render: { fillStyle: this.colors.background }, label: "circleB" }),
            circleC: this.modules.Bodies.circle(this.obj.divWidth / 2, this.obj.divHeight / 2, 10, { isStatic: true, collisionFilter: { group: -1, }, render: { fillStyle: this.colors.wall }, label: "circleC" }),
            centerLine: this.modules.Bodies.rectangle(this.obj.divWidth / 2, this.obj.divHeight / 2, this.obj.divWidth, 10, { isStatic: true, collisionFilter: { group: -1, }, render: { fillStyle: this.colors.wall }, label: "centerLine" }),

            leftPaddle: this.modules.Bodies.rectangle(this.obj.leftPaddle.x, this.obj.leftPaddle.y, this.obj.leftPaddle.width, this.obj.leftPaddle.height, {
                label: "lPadel",
                isStatic: true, render: {
                    fillStyle: this.colors.leftP
                }
            }),
            rightPaddle: this.modules.Bodies.rectangle(this.obj.rightPaddle.x, this.obj.rightPaddle.y, this.obj.rightPaddle.width, this.obj.rightPaddle.height, {
                label: "rPadel",
                isStatic: true, render: {
                    fillStyle: this.colors.rightP
                }
            }),
            myPaddle: this.modules.Bodies.rectangle(0, 0, 0, 0, { isStatic: true }),
            othersPaddle: this.modules.Bodies.rectangle(0, 0, 0, 0, { isStatic: true }),
            roof: this.modules.Bodies.rectangle(this.obj.wallTop.x, this.obj.wallTop.y, this.obj.wallTop.width, this.obj.wallTop.height, {
                label: "roof",
                isStatic: true,
                render: {
                    fillStyle: 'blue'
                }
            }),
            ground: this.modules.Bodies.rectangle(this.obj.wallBottom.x, this.obj.wallBottom.y, this.obj.wallBottom.width, this.obj.wallBottom.height, {
                label: "ground",
                isStatic: true,
                render: {
                    fillStyle: 'red'
                }
            }),
            wall: this.modules.Bodies.rectangle(this.obj.wallRight.x, this.obj.wallRight.y, this.obj.wallRight.width, this.obj.wallRight.height, {
                label: "wallRight",
                isStatic: true,
                render: {
                    fillStyle: this.colors.wall
                }
            }),
            wallLeft: this.modules.Bodies.rectangle(this.obj.wallLeft.x, this.obj.wallLeft.y, this.obj.wallLeft.width, this.obj.wallLeft.height, {
                label: "wallLeft",
                isStatic: true,
                render: {
                    fillStyle: this.colors.wall
                }
            }),

        }

        this.socket.on("paddleAssigned", (data) => {
            console.log("recieved paddle", data)
            this.paddleSide = data
            if (this.paddleSide == "left") {
                this.bodies.myPaddle = this.bodies.leftPaddle
                this.bodies.othersPaddle = this.bodies.rightPaddle

            } else {
                this.bodies.myPaddle = this.bodies.rightPaddle
                this.bodies.othersPaddle = this.bodies.leftPaddle

            }

            this.updateOtherPaddle()
        })

    }

    saveMeasurements(div: { height: number, width: number }) {

        const obj = {
            divWidth: 375,
            divHeight: 375 * (16 / 9),
            ball: { x: div.height / 2, y: div.width / 2, radius: 20 },
            wallBottom: { x: div.width / 2, y: div.height, width: div.width, height: 20 },
            wallTop: { x: div.width / 2, y: 0, width: div.width, height: 20 },
            wallLeft: { x: 0, y: div.height / 2, width: 20, height: div.height },
            wallRight: { x: div.width, y: div.height / 2, width: 20, height: div.height },
            leftPaddle: { x: div.width / 2, y: 50, width: 100, height: 20 },
            rightPaddle: { x: div.width / 2, y: div.height - 50, width: 100, height: 20 },
        }
        return obj
    }
    createModules() {
        if (this.matterContainer) {

            this.objects.engine = this.modules.Engine.create();
            this.objects.render = this.modules.Render.create({
                element: this.matterContainer,
                engine: this.objects.engine,
                options: {
                    background: "transparent",
                    wireframes: false,
                    showAngleIndicator: false,
                    width: this.matterContainer.clientWidth,
                    height: this.matterContainer.clientHeight,
                }
            }),
                this.objects.runner = this.modules.Runner.create(),
                this.objects.mouse = this.modules.Mouse.create(this.objects.render.canvas),
                this.objects.mouseConstraint = this.modules.MouseConstraint.create(this.objects.engine, {
                    mouse: this.objects.mouse,
                    constraint: {
                        stiffness: 0.2,
                        render: {
                            visible: false
                        }
                    }
                })
        }
    }


    createBodies() {

        this.modules.Composite.add(this.objects.engine.world, [this.bodies.circleA, this.bodies.circleB, this.bodies.circleC, this.bodies.centerLine, this.bodies.ball, this.bodies.leftPaddle, this.bodies.wall, this.bodies.wallLeft, this.bodies.rightPaddle]);
    }
    events() {

        Events.on(this.objects.mouseConstraint, "mousemove", (e) => {
            this.modules.Body.setPosition(this.bodies.myPaddle, { x: e.mouse.position.x, y: this.bodies.myPaddle.position.y });
            this.socket?.emit(this.paddleSide, { x: e.mouse.position.x, y: this.bodies.myPaddle.position.y })

        })

        Events.on(this.objects.mouseConstraint, "mouseup", (e) => {
            // this.modules.Body.setVelocity(this.bodies.ball, { x: 5, y: 5 });
            this.socket?.emit("mouseUp", { x: this.bodies.myPaddle.position.x, y: e.mouse.position.y })

        })
    }

    run() {
        this.modules.Composite.add(this.objects.engine.world, [this.objects.mouseConstraint]);

        this.modules.Render.run(this.objects.render);
        this.modules.Runner.run(this.objects.runner, this.objects.engine);
    }

    windowSizeEvent(setHeight: React.Dispatch<React.SetStateAction<number>>) {
        const handleResize = () => {

            setHeight(this.matterContainer.clientWidth * 16 / 9); // Update the width based on the window size
            this.onWindowSizeChange()
        };

        window.addEventListener('resize', handleResize);

        return () => {
            window.removeEventListener('resize', handleResize); // Clean up the event listener
        };
    }
    onWindowSizeChange() {
        function calculateRectangleVertices(dimensions: { width: number, height: number, x: number, y: number }) {
            const halfWidth = dimensions.width / 2;
            const halfHeight = dimensions.height / 2;

            const vertices = [
                { x: dimensions.x - halfWidth, y: dimensions.y - halfHeight },   // Top-left vertex
                { x: dimensions.x + halfWidth, y: dimensions.y - halfHeight },   // Top-right vertex
                { x: dimensions.x + halfWidth, y: dimensions.y + halfHeight },   // Bottom-right vertex
                { x: dimensions.x - halfWidth, y: dimensions.y + halfHeight }    // Bottom-left vertex
            ];

            return vertices;
        }

        const aspectRatio = 16 / 9; // Replace with your desired aspect ratio
        const newWidth = this.matterContainer.clientWidth; // Replace with your desired width
        const newHeight = this.matterContainer.clientHeight; // Replace with your desired height
        const oldWidth = this.obj.divWidth
        const oldHeight = this.obj.divHeight
        console.log(newWidth, newHeight, oldWidth, oldHeight)
        const widthRatio = newWidth / oldWidth;
        const heightRatio = newHeight / oldHeight;
        // this.modules.Body.set(ground, 'width', window.innerWidth);
        const modules = this.modules
        const dimenssions = this.obj
        const bodies = this.bodies
        console.clear()
        this.modules.Composite.allBodies(this.objects.engine.world).forEach(function (body) {
            switch (body.label) {
                case 'lPadel':
                    modules.Body.set(body, 'width', dimenssions.leftPaddle.width * widthRatio);
                    break;
                case 'rPadel':
                    modules.Body.set(body, 'width', dimenssions.rightPaddle.width * widthRatio);
                    break;
                case 'roof':
                    modules.Body.set(body, 'width', dimenssions.wallTop.width * widthRatio);
                    break;

                case 'ground':
                    modules.Body.set(body, 'width', dimenssions.wallBottom.width * widthRatio);
                    break;
                case 'wallRight':
                    var  scaleX = newWidth / oldWidth
                    var  scaleY = oldHeight / oldScreen.h;
                    console.log(body.label)
                    if (body.label !== "ball")
                    Matter.Body.scale(body, scaleX, scaleY);
                    modules.Body.set(body, 'width', dimenssions.wallRight.width * widthRatio);
                    break;
                case 'wallLeft':
                    const vertices = calculateRectangleVertices(dimenssions.wallLeft)
                    break;
                default:
                    // Handle cases for other bodies if necessary
                    console.log('Default case');
            }
            // var  scaleX = newScreen.w / oldScreen.w
            // var  scaleY = newScreen.h / oldScreen.h;
            // console.log(body.label)
            // if (body.label !== "ball")
            // Matter.Body.scale(body, scaleX, scaleY);
            // // Update dimensions
            // var  scaleX = newWidth / oldWidth
            // var  scaleY = newHeight / oldHeight
            // // Update position
            // var newPosition = {
            //   x: body.position.x * scaleX,
            //   y: body.position.y * scaleY
            // };
            // Matter.Body.setPosition(body, newPosition);
        });
        this.modules.Engine.update(this.objects.engine)

    }

    socketStuff() {
        this.socket.on('ballPosition', (data) => {
            // Update the ball's position
            this.bodies.ball.position.x = data.x
            this.bodies.ball.position.y = data.y
            // console.log(this.bodies.ball.position.x, this.bodies.ball.position.y)

        });


    }

    updateOtherPaddle() {
        if (this.paddleSide.length > 1) {
            // Update the other's paddle position
            if (this.paddleSide == "left")
                this.socket.on("right", (data) => {
                    this.modules.Body.setPosition(this.bodies.othersPaddle, { x: data.x, y: data.y });
                });
            else
                this.socket.on("left", (data) => {
                    this.modules.Body.setPosition(this.bodies.othersPaddle, { x: data.x, y: data.y });
                });

        }
    }

    updateGameScore(setScore: SetScoreFn, setCountDown: SetCountDownfn) {
        this.socket.on('score', (data) => {
            const receivedScore = data.score;
            setScore(receivedScore);
            setCountDown(0)
            console.log(receivedScore)
        });
    }



}



